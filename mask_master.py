#  
# Forethink Oy, 2020
#
# Managing Feed optimization using Masks
#
# Prototype for handling masks that restrict AI to make changes to Decks.
# Interface will be designed later.
# Mask is a table of users/ products, it is initialized periodically by reading 
# from Firebase the lists of users and products, and the new pairs (user,product) are
# first masked to be out of feed optimization by autogeneration.
# Generates mask mask datastructure by setting indexing on products and having column for each user.
#
# Mask cell values for (user,product):
# F = full mask, autogeneration does not touch
# A = Add events are allowed
# D = drop events are allowed
# G = Go freely, both add and drop are allowed

import pandas as pd
import plotly.express as px
import os
 
def initialize(users, products):
    global mask
    for u in users:
        for p in products:
            mask.loc[p,u] = 'F' # Full mask, autogeneration does not touch/handle these
    
# setting masks for users between ids umin and umax as well as products between 
# pmin and pmax, the mask value is set to maskValue

# rough version, use the one below!
def alfa_beta_rough(umin,umax,pmin,pmax,maskValue):
    global mask    
    mask.loc[pmin:pmax, umin: umax] = maskValue 

def alfa_beta(users, products,umin,umax,pmin,pmax,maskValue):
    global mask  
    for u in users:
        if u >= umin and u <= umax: 
            for p in products:
                if p >= pmin and p <= pmax: 
                    if mask.loc[p, u] == "A" and maskValue == "D": 
                        mask.loc[p, u] = "G" 
                    elif mask.loc[p, u] == "D" and maskValue == "A": 
                        mask.loc[p, u] = "G" 
                    else:  
                        mask.loc[p, u] = maskValue 

# printing out the mask table to screen, later Dashboard shows and manages masks.    
def show_slice(umin,umax,pmin,pmax):
    global mask
    result = mask.loc[pmin:pmax, umin:umax] 
    print(result)

def can_we(action, product, user):
    global mask
    if mask.loc[product,user] == 'G':
        return(True)
    elif action == 'Add' and mask.loc[product,user] == 'A':
        return(True)
    elif action == 'Drop' and mask.loc[product,user] == 'D':
        return(True)
    else:
        return(False)
        
def convert(users, products):
    global mask
    global mask_frame
    for u in users:
        for p in products:
            MaskValue  = mask.loc[p,u]

            if MaskValue == 'F':
#                MaskInteger = '#89a919'
                MaskInteger = int(10)
            elif MaskValue == 'A':
#                MaskInteger = '#1989a9'
               MaskInteger = int(20)
            elif MaskValue == 'D':
#                MaskInteger = '#a98d19'
                MaskInteger = int(30)
            elif MaskValue == 'G':
#                MaskInteger = '#5989a9'
                MaskInteger = int(40)
            else:
#                MaskInteger = '#191919'
                MaskInteger = int(50)

# use the letters anyhow                
            mask_frame = mask_frame.append({'product':p,'user':u,'mask':MaskValue}, ignore_index=True)
    return(mask_frame)

# In proto just toy user and product ids,  later read and updated from Firebase    
users =['u1','u2','u3','u4','u5','u6','u7','u8','u9','u10','u11','u12']
products = ['p1','p2','p3','p4','p5','p6','p7','p8','p9']

print('Products are {}, in future scraped from Firebase'.format(products))
print('End-users  are {}, scaped in future versions from BigQuery'.format(users))

# Generating the mask datastructure by setting indexing on products and having column for each user
mask = pd.DataFrame(columns=users,index=products)

initialize(users,products)

print('Initially no autogenerated Feed optimization is allowed, thus F in all cells.')

show_slice('u1','u8','p1','p6')

# in the example product p3 for user u3 gets A+D making it G

print('Freeing the mask for some Add and Drop actions, and both explicitly for u7/p6')

print('alfa_beta(users, products,\'u2\',\'u4\',\'p2\',\'p4\',\'A\') # partial call to allow Adds')
alfa_beta(users, products,'u2','u4','p2','p4','A') # Adding allowed
print('alfa_beta(users, products,\'u3\',\'u6\',\'p3\',\'p5\',\'D\') # partial call to allow Drops')
alfa_beta(users, products,'u3','u6','p3','p5','D') # Dropping allowed
print('alfa_beta(users, products,\'u7\',\'u7\',\'p6\',\'p6\',\'G\') # partial call to allow just u7 be feed optimized both with Adds and Drops')
alfa_beta(users, products,'u7','u7','p6','p6','G') # GO no restriction (G = A + D)
               
show_slice('u1','u8','p1','p6')

print('And finally testing some specific user product pairs for autogeneration actions being allowed.')
print('Can we {} {} for {}, the status is {}'.format('Add', 'p2', 'u3',can_we('Add', 'p2', 'u3')))

print('Can we {} {} for {}, the status is {}'.format('Drop', 'p2', 'u3',can_we('Drop', 'p2', 'u3')))

# Plotting the masks

mask_frame = pd.DataFrame(columns=['product','user','mask'])
mask_frame = convert(users, products)
print(mask_frame)
                              

#events = df["event_name"].unique().tolist()

fig = px.scatter(mask_frame, x="product", y="user", color="mask")

fig.update_traces(marker=dict(size=24,
                              line=dict(width=2,
                                        color='white')),
#                                        color='DarkSlateGrey')),
                  selector=dict(mode='markers'))

title = ""
for index, value in enumerate(products):

    title = "MASK F=no auto, D = can be dropped, A = can be added, G= D+A"
        
    fig.update_layout(
    title=title,
    xaxis_title="Products",
    yaxis_title="Shoppers",
    font=dict(
        family="Courier New, monospace",
        size=8,
        color="#7f7f7f"
    )
)
    
fig.show()

if not os.path.exists("images"):
    os.mkdir("images")

fig.write_image("images/mask_master.png")

